using System.Collections.Generic;
using System.Linq;

namespace Facepunch.InteropGen;

internal partial class ManagerWriter : BaseWriter
{
	public ManagerWriter( Definition definitions, string targetName ) : base( definitions, targetName )
	{

	}

	public override void Generate()
	{
		Header();
		WriteLine( $"#ifndef {definitions.Ident}_GEN_H" );
		WriteLine( $"#define {definitions.Ident}_GEN_H" );

		HelperFunctions();

		/*
		Imports();
		PointerStructs();
		*/

		//Exports();
		NativeInterop();

		WriteLine( $"#endif" );
	}

	private void Header()
	{
		WriteLine( "// <auto-generated>" );
		WriteLine( "// This file was generated by a tool." );
		WriteLine( "// Changes to this file may cause incorrect behavior and will be lost if" );
		WriteLine( "// the code is regenerated." );
		WriteLine( "// </auto-generated>" );


		/*
		WriteLine( "using System;" );
		WriteLine( "using System.Collections.Generic;" );
		WriteLine( "using System.Runtime.CompilerServices;" );
		WriteLine( "using System.Runtime.InteropServices;" );
		
		WriteLine( "" );
		*/

	}

	private void HelperFunctions()
	{
		/*
		StartBlock( $"internal static class {definitions.CustomNamespace}" );
		{
			StartBlock( "public static int Convert( Type t )" );
			{
				foreach ( Class c in definitions.Classes.OrderByDescending( x => x.ClassDepth ) )
				{
					if ( c.Native )
					{
						continue;
					}

					if ( c.Static )
					{
						continue;
					}

					WriteLine( $"if ( typeof( global::{c.ManagedNameWithNamespace} ).IsAssignableFrom( t ) ) return {c.ClassIdent};" );
				}

				WriteLine();
				WriteLine( "throw new System.Exception( $\"Can't handle type {t}\" );" );

			}
			EndBlock();
		}
		EndBlock();
		*/
	}

	private void NativeInterop()
	{
		IEnumerable<Function> exports = definitions.Classes.Where( x => x.Native == true ).SelectMany( x => x.Functions );
		IEnumerable<Function> imports = definitions.Classes.Where( x => x.Native == false ).Where( x => !ShouldSkip( x ) ).SelectMany( x => x.Functions );

		WriteLine( $"extern void *g_p{definitions.Ident}Library;" );
		WriteLine( $"extern bool g_bIs{definitions.Ident}Initialized;" );
		WriteLine();

		/*
		ErrorFunction();
		*/
		
		WriteLine( "#include \"windows.h\" " );
		WriteLine( "#include \"engine/structs.h\" " );
		WriteLine( "#ifdef _WIN32" );
		WriteLine( "#define CC __stdcall" );
		WriteLine( "#else" );
		WriteLine( "#define CC" );
		WriteLine( "#endif" );
		WriteLine();
		WriteLine("#define RW_VAR(type, name, parent, readop, writeop) RWVariable<type, parent> name{readop, writeop,this};");
		WriteLine("#define ConVar _ConVar");
		WriteLine("#define ConCommand _ConCommand");
		WriteLine("#define CUtlBuffer _CUtlBuffer");
		WriteLine("#define CUtlString _CUtlString");
		WriteLine("#define CUtlVector _CUtlVector");

		WriteLine();
		{
			int c = definitions.Classes.Where( x => x.Native == true ).Where( x => !ShouldSkip( x ) ).Sum( x =>
					{
					int i = 0;

					Class bc = x.BaseClass;

					while ( bc != null )
					{
					Class subclass = bc;
					i += 2;
					bc = bc.BaseClass;
					}

					i += x.Functions.Count;
					i += x.Variables.Count * 2;

					return i;

					} );

			c += 1;

			WriteLine();
			WriteLine( $"extern void *g_{definitions.Ident}_nativeFunctions[{c}];" );
			WriteLine( $"extern void *g_{definitions.Ident}_callbackFunctions[{imports.Count()}];" );
			WriteLine( $"extern int g_{definitions.Ident}_iStructSizes[{definitions.Structs.Count()}];" );
		}

		WriteLine( "typedef int(*FnBindingsImportDelegate)( int hash, void* imports, void* exports, int* structSizes );" );
		WriteLine();

		int i = 0;
		StartBlock( $"inline void {definitions.Ident}BindingsInitialize()" );
		{
			WriteLine( $"if ( g_bIs{definitions.Ident}Initialized ) return;" );
			WriteLine();

			WriteLine( $"g_p{definitions.Ident}Library = LoadLibraryA(\"{definitions.NativeDll}\");" );
			WriteLine( $"if(!g_p{definitions.Ident}Library)" );
			WriteLine( $"	_exit(1);" );

			WriteLine();
			WriteLine( $"FnBindingsImportDelegate igen_{definitions.Ident} = (FnBindingsImportDelegate)GetProcAddress( (HMODULE)g_p{definitions.Ident}Library, \"igen_{definitions.Ident}\" );" );
			WriteLine( $"if(!igen_{definitions.Ident})" );
			WriteLine( $"	_exit(1);" );


			//
			// Managed Functions
			//
			{
				WriteLine();
				WriteLine( $"void *managedFunctions[{imports.Count()}] = " );
				StartBlock( null );
				foreach ( Function f in imports )
				{
					Class c = f.Class;
					IEnumerable<string> managedArgs = c.SelfArg( false, f.Static ).Concat( f.Parameters ).Concat( new[] { f.Return } ).Where( x => x.IsRealArgument ).Select( x => $"{x.GetManagedDelegateType( true )}" );
					string managedArgss = $"{string.Join( ", ", managedArgs )}";

					WriteLine( $"(void*) (g_{definitions.Ident}_callbackFunctions[{i}])," );
					i++;
				}
				EndBlock( ";" );
			}

			i = 0;


			/*
			{
				int c = definitions.Classes.Where( x => x.Native == true ).Where( x => !ShouldSkip( x ) ).Count();
				WriteLine();
				WriteLine( $"var structSizes = new int[]" );
				StartBlock( null );

				foreach ( Struct s in definitions.Structs )
				{
					if ( ShouldSkip( s ) )
					{
						continue;
					}

					string size_of = $"sizeof( {s.ManagedNameWithNamespace} )";

					WriteLine( $"{size_of}," );
					i++;
				}

				EndBlock( ";" );
			}
			*/

			WriteLine();
			if (definitions.Ident != "hammer")
				WriteLine( $"igen_{definitions.Ident}( *(unsigned short*)(((uint64_t)igen_{definitions.Ident})+23), managedFunctions, g_{definitions.Ident}_nativeFunctions, g_{definitions.Ident}_iStructSizes );" );
			else
				WriteLine( $"igen_{definitions.Ident}( *(unsigned short*)(((uint64_t)igen_{definitions.Ident})+8), managedFunctions, g_{definitions.Ident}_nativeFunctions, g_{definitions.Ident}_iStructSizes );" );

			i = 1;


			i = 1;
		

			WriteLine( $"g_bIs{definitions.Ident}Initialized = true;" );
		}
		EndBlock();

		i = 1;
		foreach ( Class c in definitions.Classes.Where( x => x.Native == true ) )
		{
			if ( ShouldSkip( c ) )
			{
				continue;
			}

			string namespc = $"{c.ManagedNamespace}.{c.ManagedName}".Trim( '.' );

			Class bc = c.BaseClass;

			if (c.NativeNameWithNamespace == "CUtlVector<float>")
				WriteLine( $"template <>" );
			if (c.NativeNameWithNamespace == "CUtlVector<HRenderTexture>")
				WriteLine( $"template <>" );
			if (c.NativeNameWithNamespace == "CUtlVector<uint32>")
				WriteLine( $"template <>" );
			if (c.NativeNameWithNamespace == "CUtlVector<Vector>")
				WriteLine( $"template <>" );
			if (c.NativeNameWithNamespace == "CUtlVector<PhysicsTrace::Result>")
				WriteLine( $"template <>" );
			if (c.NativeNameWithNamespace == "CUtlVector<CUtlString>")
				WriteLine( $"template <>" );

			if (c.NativeNameWithNamespace =="PhysicsTrace")
				StartBlock( $"class PhysicsTrace_" );
			else if (c.NativeNameWithNamespace =="global") {}
			else if (c.NativeNameWithNamespace =="globalSteam") {}
			else
				StartBlock( $"class {c.NativeNameWithNamespace}" );

			if (c.NativeNameWithNamespace =="global") {}
			else if (c.NativeNameWithNamespace =="globalSteam") {}
			else {
				WriteLine( $"public:" );
				WriteLine( $"void *m_pSelf;" );
				StartBlock( $"inline operator {c.NativeNameWithNamespace}*()" );
				WriteLine($"return ({c.NativeNameWithNamespace}*)m_pSelf;");
				EndBlock();
			}

			/*
			   while ( bc != null )
			   {
			   Class subclass = bc;

			   WriteLine( $"{namespc}.{InternalNative}.From_{subclass.ManagedName}_To_{c.ManagedName} = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[{i++}];" );
			   WriteLine( $"{namespc}.{InternalNative}.To_{subclass.ManagedName}_From_{c.ManagedName} = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[{i++}];" );

			   bc = bc.BaseClass;
			   }
			   */
			while ( bc != null )
			{
				Class subclass = bc;

				WriteLine( $"//{namespc}.{InternalNative}.From_{subclass.ManagedName}_To_{c.ManagedName} = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[{i++}];" );
				WriteLine( $"//{namespc}.{InternalNative}.To_{subclass.ManagedName}_From_{c.ManagedName} = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[{i++}];" );

				bc = bc.BaseClass;
			}

			foreach ( Function f in c.Functions )
			{
				IEnumerable<string> managedArgs = c.SelfArg( false, f.Static ).Concat( f.Parameters ).Where( x => x.IsRealArgument ).Select( x => $"{x.GetManagedDelegateType( false )}" ).Concat( new[] { f.Return.GetManagedDelegateType( true ) } );
				string managedArgss = $"{string.Join( ", ", managedArgs )}";

				string nogc = "";

				if ( f.IsNoGC )
				{
					nogc = "[SuppressGCTransition]";
				}

				string varNamePrepend = "";
				if ( f.Body != null )
				{
					varNamePrepend = "__";
				}

				IEnumerable<string> nativeArgs = c.SelfArg( true, f.Static ).Concat( f.Parameters ).Where( x => x.IsRealArgument && x.Name != "self").Select( x => $"{x.GetNativeDelegateType( true )} {x.Name}" );
				string nativeArgS = string.Join( ", ", nativeArgs );
				IEnumerable<string> nativeArgsSelf = c.SelfArg( true, f.Static ).Concat( f.Parameters ).Where( x => x.IsRealArgument ).Select( x => $"{x.GetNativeDelegateType( true )} {varNamePrepend}{x.Name}" );
				string nativeArgSelfS = string.Join( ", ", nativeArgsSelf );

				IEnumerable<string> args = f.Parameters.Select( x => x.Name ).Where( x => x != null );

				// Constructor
				if ( f.Special.Contains( "new" ) )
				{
					StartBlock( $"{c.NativeNameWithNamespace.Replace("fpxr::","")}({nativeArgS}) " );
					string argsS = string.Join( ", ", args );
					WriteLine( $"m_pSelf = ((void*(*)({nativeArgSelfS}))g_{definitions.Ident}_nativeFunctions[{i++}])({argsS});" );
				}
				else
				{
					if (i==1772)
					{
						i++;
						continue;
					}
					// General function calls
					if ((f.Static || c.Static)&&!c.NativeNameWithNamespace.StartsWith("g_"))
						WriteLine("static");
					StartBlock( $"inline {f.Return.GetNativeDelegateType( false )} {f.Name}({nativeArgS}) " );
					if (!(f.Static || c.Static))
					{
						nativeArgsSelf = nativeArgsSelf.Prepend("void*");
						args = args.Prepend("m_pSelf");
					}
					string argsS = string.Join( ", ", args );
					if (!f.Return.IsVoid)
						WriteLine("return");
					WriteLine( $"(({f.Return.GetNativeDelegateType( false )}(*)({nativeArgSelfS}))g_{definitions.Ident}_nativeFunctions[{i++}])({argsS});" );
				}
				EndBlock();
			}

			foreach ( Variable f in c.Variables )
			{
				WriteLine( $"RW_VAR({f.Return.GetNativeDelegateType( false )},{f.Name},{c.NativeNameWithNamespace},g_{definitions.Ident}_nativeFunctions[{i++}],g_{definitions.Ident}_nativeFunctions[{i++}]);" );
			}
			if (c.NativeNameWithNamespace == "global") {}
			else if (c.NativeNameWithNamespace == "globalSteam") {}
			else
				EndBlock(";");
		}

		WriteLine("#undef ConVar");
		WriteLine("#undef ConCommand");
		WriteLine("#undef CUtlBuffer");
		WriteLine("#undef CUtlString");
		WriteLine("#undef CUtlVector");

		StartBlock( $"inline void {definitions.Ident}Free()" );
		{
			WriteLine( $"if ( g_p{definitions.Ident}Library == 0 ) return;" );
			WriteLine( $"FreeLibrary( (HMODULE)g_p{definitions.Ident}Library );" );
			WriteLine( $"g_p{definitions.Ident}Library = 0;" );
			WriteLine( $"g_bIs{definitions.Ident}Initialized = false;" );
		}
		EndBlock();

		if ( definitions.InitFrom == "Managed" )
		{
			StartBlock( "internal unsafe static partial class Initialize" );
			{
				ManagedInit();
			}
			EndBlock();
		}

	}

	private void ErrorFunction()
	{
		/*
		WriteLine( "[UnmanagedFunctionPointer( CallingConvention.Cdecl )]" );
		WriteLine( "internal delegate void _ErrorFunction( string message );" );
		WriteLine();
		*/
	}

	private void ManagedInit()
	{
		WriteLine( "[UnmanagedFunctionPointer( CallingConvention.Cdecl )]" );
		WriteLine( "internal delegate void _InitFunc( IntPtr initFunc, IntPtr function_pointers, int count );" );
		WriteLine();
		WriteLine( "[UnmanagedFunctionPointer( CallingConvention.Cdecl )]" );
		WriteLine( "internal delegate void _ManagedInit( int hash, IntPtr fp, int* struct_sizes );" );
		WriteLine();
		StartBlock( "public static void FromLibrary( string dllPath )" );
		{
			WriteLine( $"var library = NativeLibrary.Load( dllPath );" );
			WriteLine( $"if ( library == null ) throw new System.Exception( $\"Couldn't load {{dllPath}}\" );" );
			WriteLine( $"" );
			WriteLine( $"var initFunc = NativeLibrary.GetExport( library, \"InitInterop_{definitions.Hash}\" );" );
			WriteLine( $"if ( initFunc == null ) throw new System.Exception( $\"Couldn't find export in {{dllPath}} - possibly out of date?\" );" );
			WriteLine( $"" );
			WriteLine( $"var fp = Marshal.GetFunctionPointerForDelegate<_ManagedInit>( NativeInterop.Initialize );" );
			WriteLine( $"" );

			int exportCount = definitions.Classes.Where( x => x.Native == false ).SelectMany( x => x.Functions ).Count();

			if ( exportCount > 0 )
			{
				StartBlock( $"IntPtr[] functions = new[]" );
				{
					foreach ( Class c in definitions.Classes.Where( x => x.Native == false ) )
					{
						if ( ShouldSkip( c ) )
						{
							continue;
						}

						foreach ( Function f in c.Functions )
						{
							WriteLine( $"FunctionPointerFor<Exports.{f.MangledName}_d>( Exports.{f.MangledName} )," );
						}
					}
				}
				EndBlock( ";" );

				WriteLine( $"" );
				WriteLine( $"var init = Marshal.GetDelegateForFunctionPointer<_InitFunc>( initFunc );" );
				WriteLine( $"" );
				StartBlock( "fixed ( IntPtr* ptr = functions )" );
				{
					WriteLine( "init( fp, (IntPtr)ptr, functions.Length );" );
				}
				EndBlock();
			}
			else
			{
				WriteLine( $"var init = Marshal.GetDelegateForFunctionPointer<_InitFunc>( initFunc );" );
				WriteLine( $"" );
				WriteLine( "init( fp, IntPtr.Zero, 0 );" );
			}


		}
		EndBlock();

		WriteLine();
		WriteLine( $"// Store for delegates, to stop them getting garbage collected" );
		WriteLine( $"static List<Delegate> delegateStore = new List<Delegate>();" );
		WriteLine( $"" );
		WriteLine( $"// Store the delegate and return a function pointer" );
		StartBlock( $"static IntPtr FunctionPointerFor<T>( T del ) where T : Delegate" );

		WriteLine( $"	delegateStore.Add( del );" );
		WriteLine( $"	return Marshal.GetFunctionPointerForDelegate<T>( del );" );
		EndBlock();
	}
}
